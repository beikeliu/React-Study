#### useState
1. react的所有状态都应视为不可变的，要避免直接改变引用类型的数据，而是始终set一份新的数据

> 调试：如果你使用console.log并且不改变状态，你过去的日志将不会被最近的状态变化所破坏。所以你可以清楚地看到状态在渲染之间是如何变化的。
> 
> 优化：如果前一个道具或状态与下一个相同，则常见的 React优化策略依赖于跳过工作。如果你从不改变状态，那么检查是否有任何变化是非常快的。如果prevObj === obj，您可以确定它内部没有任何变化。
> 
> 新功能：我们正在构建的新 React 功能依赖于将状态视为快照。如果您正在改变过去版本的状态，这可能会阻止您使用新功能。
> 
> 需求变更：某些应用程序功能，如实现撤消/重做、显示变更历史或让用户将表单重置为较早的值，在没有任何变化时更容易实现。这是因为您可以在内存中保留过去的状态副本，并在适当的时候重用它们。如果您从可变方法开始，以后可能很难添加此类功能。
> 
> 更简单的实现：因为 React 不依赖于变异，所以它不需要对你的对象做任何特殊的事情。它不需要劫持它们的属性，总是将它们包装到代理中，或者像许多“反应式”解决方案那样在初始化时做其他工作。这也是 React 允许您将任何对象放入状态的原因——无论对象有多大——没有额外的性能或正确性缺陷。

2. setState之后，不是立即去通知模板渲染的，而是排队在下一次渲染之前，批量set当次渲染需要改变的数据。

> 这使您可以更新多个状态变量——甚至来自多个组件——而不会触发太多重新渲染。但这也意味着在您的事件处理程序及其中的任何代码完成之前， UI 不会更新。这种行为，也称为批处理，可以让你的 React 应用程序运行得更快。它还避免处理令人困惑的“半成品”渲染，其中仅更新了一些变量。

3. 同一个状态，在一次渲染中，需要多次更改的处理方式：
```JavaScript
const [number, setNumber] = useState(0);
// x 当次渲染中number始终为0，也就是两次setNumber(0+1)
setNumber(number + 1)
setNumber(number + 1) 

// √ 传递一个函数作为参数，该函数会根据前一个状态计算下一个状态队列
setNumber(n => n + 1) 
setNumber(n => n + 1) 
```
